let lib = import "src/lib.lx"
let types = import "src/types.lx"
let object = import "src/object.lx"

let concat = lib.concat
let range = lib.range

// let's get fancy with the names?
let fold = lib.reduce
let each = lib.foreach
let map = lib.map

let VERSION = 0

let ValueType = types.ValueType
let ObjType = object.ObjType

// obj layout
// LX:        2
// VERSION:   1
// FLAGS:     1 , 8 bits
//     0000 0001 -> debug
// OBJSIZE:   4 little endian
// CHUNKS:    2 little endian -> we can have up to 65536 chunks
// TBD:       16 - (2+1+1+4+2) = 6
// # chunk layout
// CHUNK_SIZE: 4 little endian
//   CHUNK_NAME_SIZE: 2 little endian
//        CHUNK_NAME: string, vary length, aka function name
// CODE_SECTION: ?
//      SIZE: 4 little endian
//      CODE: various length
//            CODE_SECTION guaranteed to be followed by 5 bytes of CONST_SECTION header
// CONST_SECTION: follow right after a CODE_SECTION
//      SIZE: 4  let's leave size here, so it's possible for us to jump to next chunk
//      CONST_COUNT: 1
//   every const is like
//      TYPE:  1
//      VALUE: 1 bit type + type dependent layout(length)
//        BOOL:   1 + 1
//        NIL:    1
//        NUMBER: 1 + 8 (double)
//        OBJ:    1 + 1 (obj type) + obj type dependent layout(length)
//          STRING:   4 little endian size + actual string
//          FUNCTION: 0, we rely on the build order to stay the same
// DEBUG_SECTION:
//      SIZE: 4 little endian
//      FILEPATH_LENGTH: 2 file path length
//      FILEPATH: vary length
//      TOKEN_LINE_NUMBER: 2 bytes each (which means we would only support line no. up to 65535)

fn int32ToBytes(num) {
  // always return 4 bytes
  let bytes = [0, 0, 0, 0]
  bytes[0] = lib.tohex(num % 256)
  num = lib.floor(num / 256)
  bytes[1] = lib.tohex(num % 256)
  num = lib.floor(num / 256)
  bytes[2] = lib.tohex(num % 256)
  num = lib.floor(num / 256)
  bytes[3] = lib.tohex(num % 256)
  return bytes
}

fn numberToDoubleBytes(num) {
  if num > 256*256 { return ["ff", "ff"] }
  let bytes = [0, 0]
  bytes[0] = lib.tohex(num % 256)
  num = lib.floor(num / 256)
  bytes[1] = lib.tohex(num % 256)
  num = lib.floor(num / 256)
  return bytes
}

fn doubleToBytes(num) {
  map(Lx.doubleToUint8Array(num), fn(n) {
    lib.tohex(n)
  })
}

fn stringToBytes(s) {
  fold(range(s), [], fn(bytes, c) {
    append(bytes, lib.tohex(lib.ord(c)))
  })
}

fn writeBytesAt(arr1, arr2, index) {
  for let i = 0; i < len(arr2) and i + index < len(arr1); i = i + 1 {
    arr1[index + i] = arr2[i]
  }
}

fn setFlags(options) {
  let flags = 0
  if options.debug {
    flags = flags + 1
  }
  return lib.tohex(flags)
}

fn buildChunkObj(function, flags) {
  let chunk = function.chunk
  let funcName = function.name

  let obj = []
  let debug = flags.debug
  let functions = []

  // reserve chunk size
  obj = concat(obj, int32ToBytes(0))

  obj = append(obj, lib.tohex(function.arity))

  // chunk name info
  obj = concat(obj, numberToDoubleBytes(len(funcName)))
  obj = concat(obj, stringToBytes(funcName))

  let codeSize = len(chunk.bytecode)
  obj = concat(obj, int32ToBytes(codeSize))
  obj = concat(obj, chunk.bytecode)

  // save start index, we will update this to actual constants size
  let constSectionStart = len(obj)
  // reserve constants section size
  obj = concat(obj, int32ToBytes(1))

  let constantsSize = len(chunk.constants)
  obj = append(obj, lib.tohex(constantsSize))

  if constantsSize > 0 {
    let constants = []
    let objTypeHandlers = {
      [ObjType.STRING]: fn(value) {
        constants = concat(constants, int32ToBytes(len(value)))
        constants = concat(constants, stringToBytes(value))
      },
      [ObjType.FUNCTION]: fn(value) {
        functions = append(functions, value)
      },
    }
    let constTypeHandlers = {
      // NOTE: not having nil or bool handlers here,
      // since those are represented directly as byte codes
      [ValueType.NUMBER]: fn(value) {
        let double = doubleToBytes(value)
        constants = concat(constants, double)
      },
      [ValueType.OBJ]: fn(val) {
        let handler = objTypeHandlers[val.kind]
        if handler {
          constants = append(constants, lib.tohex(val.kind))
          handler(val.value)
        } else {
          // should be unreachable
          print("Invalid obj handler type: " + str(val.kind))
          Lx.exit(55)
        }
      },
    }
    each(chunk.constants, fn(val) {
      let handler = constTypeHandlers[val.kind]
      if handler {
        constants = append(constants, lib.tohex(val.kind))
        handler(val.value)
      } else {
        // should be unreachable
        print("Invalid value handler type: " + str(val.kind))
        Lx.exit(55)
      }
    })

    // update constants section size
    writeBytesAt(obj, int32ToBytes(len(constants) + 1), constSectionStart)
    obj = concat(obj, constants)
  }

  if debug {
    // save start index, we will update this to actual debug size
    let debugSectionStart = len(obj)
    // reserve debug section size
    obj = concat(obj, int32ToBytes(0))
    let debugLines = []

    let filename = chunk.filename
    let filePathStringLength = numberToDoubleBytes(len(filename))
    debugLines = concat(debugLines, filePathStringLength)
    debugLines = concat(debugLines, stringToBytes(filename))

    each(chunk.lines, fn(line) {
      debugLines = concat(debugLines, numberToDoubleBytes(line))
    })

    // update debug section size
    writeBytesAt(obj, int32ToBytes(len(debugLines)), debugSectionStart)
    obj = concat(obj, debugLines)
  }

  // update chunk total size
  writeBytesAt(obj, int32ToBytes(len(obj) - 4), 0)

  return {
    obj: obj,
    functions: functions,
  }
}

fn dumpObj(obj) {
  // print formatted obj in plain text
  let buffered = ""
  let totalSize = len(obj)
  for let i = 0; i < totalSize; {
    for let j = i; j < i + 16 and j < totalSize; j = j + 1 {
      buffered = buffered + obj[j]
      if j % 2 == 1 {
        buffered = buffered + " "
      }
    }

    i = i + 16

    if len(buffered) > 500 {
      print(buffered)
      buffered = ""
    } else {
      buffered = buffered + "\n"
    }
  }
  print(buffered)
}

fn objbuilder(main, debug) {
  let obj = []

  let flags = {
    debug: debug,
  }

  let header = ["4c", "58", lib.tohex(VERSION), setFlags(flags)]
  let fillRest = 16 - len(header)
  each(range(fillRest), fn() {
    header = append(header, "00")
  })
  obj = concat(obj, header)

  let functions = [main]
  for let i = 0; i < len(functions); i = i + 1 {
    let function = functions[i]
    let chunkObj = buildChunkObj(function, flags)
    functions = concat(functions, chunkObj.functions)
    obj = concat(obj, chunkObj.obj)
  }

  // update obj size
  let totalSize = len(obj)
  writeBytesAt(obj, int32ToBytes(totalSize), 4)

  // update chunks count
  writeBytesAt(obj, numberToDoubleBytes(len(functions)), 8)

  return {
    obj: obj,
    dump: fn(){dumpObj(obj)},
  }
}
