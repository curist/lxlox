let lib = import "src/lib.lx"
let types = import "src/types.lx"
let initScanner = import "src/scanner.lx"

let TOKEN = types.TOKEN
let OP = types.OP

let mod = {}

mod.debugPrint = fn(src) {
  let scanner = initScanner(src)

  let line = -1

  for true {
    let token = scanner.scanToken()

    let lineInfo = if token.line != line {
      lib.padStart(token.line, 4, " ")
      //^ XXX: ah... that's from parent global scope :o
      // not sure if this is a behavior we want...
    } else {
      "   | "
    }
    pp([
      lineInfo,
      " ", token.type, " ",
      lib.padRight(token.lexeme, 30, " "),
      "\t| ",
      types.TOKEN_NAME[token.type],
    ])

    if token.type == types.TOKEN.EOF {
      break
    }
  }
}

mod.compile = fn(src) {
  let scanner = initScanner(src)

  // XXX: future
  // TODO: put line info as debug info, as part of the bin format
  let line = -1

  let chunks = [{
    bytecode: []
    constants: []
  }]

  let parser = {
    current: 0,
    previous: 0,
    hadError: false,
    panicMode: false,
  }

  fn currentChunk() {
    // XXX: probably will need to change this later
    // Right now, the chunk pointer is stored in a module-level variable,
    // like we store other global state.
    // Later, when we start compiling user-defined functions,
    // the notion of “current chunk” gets more complicated.
    // To avoid having to go back and change a lot of code,
    // I encapsulate that logic in the currentChunk() function.
    // ^ from book text
    // https://craftinginterpreters.com/compiling-expressions.html#emitting-bytecode
    chunks[len(chunks) - 1]
  }

  fn emitByte(byte) {
    let chunk = currentChunk()
    chunk.bytecode = append(chunk.bytecode, lib.tohex(byte))
  }

  fn emitBytes(byte1, byte2) {
    emitByte(byte1)
    emitByte(byte2)
  }

  fn pushConstant(constant) {
    // TODO: check the type of the constant
    // and figure out how do we present it in `constants` array
    // XXX: should we keep a seperated constants counter?
  }

  fn errorAt(token, message) {
    if parser.panicMode {
      return
    }
    parser.panicMode = true
    pp([
      "[line ", token.line, "]",
      if token.type == TOKEN.EOF {
        " at end"
      } else if token.type == TOKEN.ERROR {
        ""
      } else {
        " at '" + token.lexeme + "'"
      },
      ": ", message,
    ])
    parser.hadError = true
  }

  fn error(message) {
    errorAt(parser.previous, message)
  }

  fn errorAtCurrent(message) {
    errorAt(parser.current, message)
  }

  fn advance() {
    parser.previous = parser.current
    for true {
      parser.current = scanner.scanToken()
      if parser.current.type != TOKEN.ERROR {
        break
      }
      errorAtCurrent("not sure what to put here")
    }
  }

  fn consume(type, message) {
    if parser.current.type == type {
      advance()
      return
    }
    errorAtCurrent(message)
  }

  fn emitReturn() {
    emitByte(OP.RETURN)
  }

  fn endCompiler() {
    emitReturn()
  }

  fn addConstant(chunk, value) {
    // TODO: support more value type
    chunk.constants = append(chunk.constants, value)
    return len(chunk.constants) - 1
  }

  fn makeConstant(value) {
    // TODO: support more value type
    let constant = addConstant(currentChunk(), value)
    if constant > 256 {
      error("Too many constants in one chunk.")
      return 0
    }
    return constant
  }

  fn emitConstant(value) {
    emitBytes(OP.CONSTANT, makeConstant(value))
  }

  fn number() {
    let value = parser.previous.literal
    if value >= 0 and value < 256 {
      emitBytes(OP.CONST_BYTE, value)
    } else {
      emitConstant(value)
    }
  }

  fn expression() {

  }

  advance()
  expression()
  consume(TOKEN.EOF, "Expect end of expression.")
  endCompiler()

  return !parser.hadError
}

mod
