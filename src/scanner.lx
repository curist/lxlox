let types = import "src/types.lx"
let TOKEN = types.TOKEN

fn initScanner(src) {
  let state = {
    start: 0,
    current: 0,
    line: 1,
  }

  let srcLen = len(src)
  fn isAtEnd() { srcLen == state.current }

  fn Token(type) {
    let lexeme = ""
    for let i = state.start; i < state.current; i = i + 1 {
      lexeme = lexeme + src[i]
    }
    return {
      type: type,
      lexeme: lexeme,
      line: state.line,
    }
  }

  fn errorToken(message) {
    return {
      type: TOKEN.ERROR,
      lexeme: message,
      line: state.line,
    }
  }

  fn advance() {
    let current = state.current
    state.current = current + 1
    return src[current]
  }

  fn match(expected) {
    if isAtEnd() {
      return false
    }
    if src[state.current] != expected {
      return false
    }
    state.current = state.current + 1
    return true
  }

  fn peek() {
    return src[state.current]
  }

  fn peekNext() {
    if isAtEnd() { nil } else src[state.current + 1]
  }

  fn skipWhitespace() {
    for !isAtEnd() {
      let c = peek()
      if c == " " or c == "\r" or c == "\t" {
        advance()
      } else if c == "\n" {
        state.line = state.line + 1
        advance()
      } else if c == "/" {
        if peekNext() == "/" {
          for peek() != "\n" and !isAtEnd() { advance() }
        } else {
          return
        }
      } else {
        return
      }
    }
  }

  let tokenHandlers = {
    ["("]: fn() { Token(TOKEN.LEFT_PAREN) },
    [")"]: fn() { Token(TOKEN.RIGHT_PAREN) },
    ["{"]: fn() { Token(TOKEN.LEFT_BRACE) },
    ["}"]: fn() { Token(TOKEN.RIGHT_BRACE) },
    [";"]: fn() { Token(TOKEN.SEMICOLON) },
    [","]: fn() { Token(TOKEN.COMMA) },
    ["."]: fn() { Token(TOKEN.DOT) },
    ["-"]: fn() { Token(TOKEN.MINUS) },
    ["%"]: fn() { Token(TOKEN.MOD) },
    ["+"]: fn() { Token(TOKEN.PLUS) },
    ["/"]: fn() { Token(TOKEN.SLASH) },
    ["*"]: fn() { Token(TOKEN.STAR) },
    // XXX: has bug in jslox that prevent us to do
    // `let x = if foo {} else bar`
    ["!"]: fn() { if match("=") { Token(TOKEN.BANG_EQUAL) } else Token(TOKEN.BANG) },
    ["="]: fn() { if match("=") { Token(TOKEN.EQUAL_EQUAL) } else Token(TOKEN.EQUAL) },
    ["<"]: fn() { if match("=") { Token(TOKEN.LESS_EQUAL) } else Token(TOKEN.LESS) },
    [">"]: fn() { if match("=") { Token(TOKEN.GREATER_EQUAL) } else Token(TOKEN.GREATER) },
  }

  return {
    scanToken: fn() {
      skipWhitespace()
      state.start = state.current

      if isAtEnd() {
        return Token(TOKEN.EOF)
      }

      let c = advance()
      if let handler = tokenHandlers[c] {
        return handler()
      }

      return errorToken("Unexpected character.")
    },
  }
}
